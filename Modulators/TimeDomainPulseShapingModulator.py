# This file is part of NFDMLab.
#
# NFDMLab is free software; you can redistribute it and/or
# modify it under the terms of the version 2 of the GNU General
# Public License as published by the Free Software Foundation.
#
# NFDMLab is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with NFDMLab; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
# 02111-1307 USA
#
# Contributors:
# Sander Wahls (TU Delft) 2019, 2021

import numpy as np
from Modulators import BaseModulator
from Helpers import NFSpectrum, next_pow2
from Helpers import SumOfShiftedWaveforms

class TimeDomainPulseShapingModulator(BaseModulator):
    """This is a conventional pulse shaping modulator that works in the time
    domain. Symbols are embedded in superposed shifted copies of a base waveform
    (e.g., a raised cosine)."""

    def __init__(self,
                 pulse_fun,
                 pulse_spacing,
                 requested_normalized_dt,
                 n_symbols_per_block,
                 n_guard_symbols,
                 make_n_samples_pow2=False):
        """Constructor.

        Parameters
        ----------
        pulse_fun : function
            A function that maps numpy.array(float) to numpy.array(complex). The
            inputs of this function are vectors of time points t.
            The outputs are vectors with the values of the base waveform at
            the corresponding t.
        pulse_spacing : float
            Spacing between two consecutive copies of the base waveform.
        required_normalized_dt : float
            The modulator will choose the number of time domain samples such
            that the time step, in normalized units, does not exceed this value.
        n_symbols_per_block : int
            Number of shifted copies of the base waveform.
        n_guard_symbols : int
            Guard symbols are zero symbols that are added to the transmission to
            avoid interference between consecutive blocks of data during
            transmission. The duration of one block generated by this modulator
            is pulse_duration*(n_symbols_per_block + n_guard_symbols).
        make_n_samples_pow2 : bool
            If True, the modular will choose the sampling interval such that the
            number of samples generated by the modulator is a power of two.
        """

        self._n_samples = int(pulse_spacing/requested_normalized_dt * (n_symbols_per_block + n_guard_symbols))
        T1 = self.n_samples/2*requested_normalized_dt
        T0 = -T1
        if make_n_samples_pow2:
            self._n_samples = next_pow2(self._n_samples)
        t = np.linspace(T0, T1, self.n_samples)
        self._sum_pulses = SumOfShiftedWaveforms(pulse_fun,
                                                 pulse_spacing,
                                                 n_symbols_per_block,
                                                 t)
        self._normalized_dt = (T1 - T0)/self.n_samples
        self._n_symbols_per_block = n_symbols_per_block

    def modulate(self, symbols):
        # Docstring is inherited from base class.
        nc = np.size(symbols)
        assert nc == self.n_symbols_per_block
        q_tx = self._sum_pulses.generate_waveform(symbols)
        return q_tx, NFSpectrum('none', 'none')

    def demodulate(self, q_rx):
        # Docstring is inherited from base class.
        symbols = self._sum_pulses.extract_symbols(q_rx)
        return symbols, NFSpectrum('none', 'none')
