# This file is part of NFDMLab.
#
# NFDMLab is free software; you can redistribute it and/or
# modify it under the terms of the version 2 of the GNU General
# Public License as published by the Free Software Foundation.
#
# NFDMLab is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with NFDMLab; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
# 02111-1307 USA
#
# Contributors:
# Sander Wahls (TU Delft) 2018-2019

import numpy as np

class SumOfShiftedWaveforms:
    """Generates a waveform by adding shifted and scaled copies of a base
    waveform. The generated waveform is of the form

        s(X) = sum_n symbol[n]*waveform_fun(X - n*waveform_spacing + offset).
    """

    def __init__(self, waveform_fun, waveform_spacing, n_waveforms, grid):
        """Constructor.

        Parameters
        ----------

        waveform_fun : function that maps np.array(float) to np.array(complex)
            The base waveform.
        waveform_spacing : float
            The spacing between the copies of the base waveform.
        n_waveforms : int
            The number of base waveforms that enter each generated waveform.
        grid : np.array(float)
            Sort array of locations at which the waveform is generated.
        """

        self._waveform_fun = waveform_fun
        self._waveform_spacing = waveform_spacing
        self._n_waveforms = n_waveforms
        self._grid = grid

        self._centers = (np.arange(0, n_waveforms)-(n_waveforms-1)/2.0)*waveform_spacing
        self._center_idx = np.zeros(n_waveforms, dtype=int)
        for n in range(0, n_waveforms):
            self._center_idx[n] = np.argmin(abs(grid - self._centers[n]))

        # Determine interval [left, right] outside of which the waveform is
        # effectively zero. This is later used to speed up the modulation
        # process when the number of carriers is getting larger.

        vals = waveform_fun(grid)
        tol = 10 * np.finfo(vals[0]).eps * np.max(np.abs(vals))
        idx = np.argwhere(np.abs(vals)>tol)
        i1 = idx[0][0]
        i2 = idx[-1][0]
        self._left = grid[i1]
        self._right = grid[i2]

    @property
    def waveform_fun(self):
        """Returns the waveform_fun that was provided to the constructor
        (read-only)."""
        return self._waveform_fun

    @property
    def waveform_spacing(self):
        """Returns the waveform_spacing that was provided to the constructor
        (read-only)."""
        return self._waveform_spacing

    @property
    def grid(self):
        """Returns the grid that was provided to the constructor (read-only)."""
        return self._grid

    @property
    def centers(self):
        """Returns a vector of grid points that contains the locations at which
        the centers of base waveforms are placed when they are summed up. Equal
        to the terms n*waveform_spacing+offset in the description of this
        class (read-only)."""
        return self._centers

    @property
    def center_idx(self):
        """Returns a vector of indices i[n] such that centers[n] = grid[i[n]]
        (read-only)."""
        return self._center_idx

    def generate_waveform(self, symbols):
        """Generates a waveform as described in the description of this class."""
        nc = np.size(symbols)
        assert nc == self._n_waveforms
        vals = np.zeros(np.size(self._grid), dtype=complex)
        for n in range(0, nc):
            shifted_grid = self.grid - self.centers[n]
            idx = np.logical_and(shifted_grid>=self._left, shifted_grid<=self._right)
            vals[idx] = vals[idx] + symbols[n]*self._waveform_fun(shifted_grid[idx])
        return vals

    def extract_symbols(self, waveform):
        """Extracts the symbols from a waveform generated by generate_waveform."""
        symbols = np.zeros(self._n_waveforms, dtype=complex)
        scl = self.waveform_fun(0.0)
        for n in range(0, self._n_waveforms):
            symbols[n] = waveform[self.center_idx[n]] / scl
        return symbols
